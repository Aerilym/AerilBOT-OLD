import TwitchClient, { HelixFollow, HelixStream, HelixUser, UserIdResolvable, HelixSubscriptionEvent } from 'twitch';
import UserChangeSubscription from './Subscriptions/UserChangeSubscription';
import FollowsToUserSubscription from './Subscriptions/FollowsToUserSubscription';
import FollowsFromUserSubscription from './Subscriptions/FollowsFromUserSubscription';
import StreamChangeSubscription from './Subscriptions/StreamChangeSubscription';
import SubscriptionEventSubscription from './Subscriptions/SubscriptionEventSubscription';
interface WebHookListenerCertificateConfig {
    key: string;
    cert: string;
}
interface WebHookListenerReverseProxyConfig {
    port?: number;
    ssl?: boolean;
    pathPrefix?: string;
}
interface WebHookListenerConfig {
    hostName?: string;
    port?: number;
    ssl?: WebHookListenerCertificateConfig;
    reverseProxy?: WebHookListenerReverseProxyConfig;
    hookValidity?: number;
}
export default class WebHookListener {
    private readonly _config;
    /** @private */ readonly _twitchClient: TwitchClient;
    private _server?;
    private readonly _subscriptions;
    static create(client: TwitchClient, config?: WebHookListenerConfig): Promise<WebHookListener>;
    private constructor();
    listen(): void;
    unlisten(): void;
    buildHookUrl(id: string): string;
    subscribeToUserChanges(user: UserIdResolvable, handler: (user: HelixUser) => void, withEmail?: boolean, validityInSeconds?: number | undefined): Promise<UserChangeSubscription>;
    subscribeToFollowsToUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<FollowsToUserSubscription>;
    subscribeToFollowsFromUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<FollowsFromUserSubscription>;
    subscribeToStreamChanges(user: UserIdResolvable, handler: (stream?: HelixStream) => void, validityInSeconds?: number | undefined): Promise<StreamChangeSubscription>;
    subscribeToSubscriptionEvents(user: UserIdResolvable, handler: (subscription: HelixSubscriptionEvent) => void, validityInSeconds?: number | undefined): Promise<SubscriptionEventSubscription>;
    /** @private */
    _changeIdOfSubscription(oldId: string, newId: string): void;
    /** @private */
    _dropSubscription(id: string): void;
    private _handleVerification;
    private _handleNotification;
}
export {};
