/// <reference types="node" />
import { LogLevel } from '@d-fischer/logger';
import { EventEmitter, Listener } from '@d-fischer/typed-event-emitter';
import Capability, { ServerCapability } from './Capability/Capability';
import Connection, { ConnectionInfo } from './Connection/Connection';
import Message, { MessageConstructor, MessageParamValues } from './Message/Message';
import MessageCollector from './Message/MessageCollector';
import * as MessageTypes from './Message/MessageTypes';
import { Notice, PrivateMessage } from './Message/MessageTypes/Commands';
import { ServerProperties } from './ServerProperties';
import { ConstructedType } from './Toolkit/TypeTools';
export declare type EventHandler<T extends Message = Message> = (message: T) => void;
export declare type EventHandlerList<T extends Message = Message> = Map<string, EventHandler<T>>;
export interface IRCCredentials {
    nick: string;
    password?: string;
    userName?: string;
    realName?: string;
}
export interface IRCClientOptions {
    connection: ConnectionInfo;
    credentials: IRCCredentials;
    webSocket?: boolean;
    channelTypes?: string;
    logLevel?: LogLevel;
    nonConformingCommands?: string[];
}
export default class IRCClient extends EventEmitter {
    protected _connection?: Connection;
    protected _registered: boolean;
    protected _options: IRCClientOptions;
    protected _credentials: IRCCredentials;
    protected _supportsCapabilities: boolean;
    protected _events: Map<string, EventHandlerList>;
    protected _registeredMessageTypes: Map<string, MessageConstructor>;
    onConnect: (handler: () => void) => Listener;
    onRegister: (handler: () => void) => Listener;
    onDisconnect: (handler: (manually: boolean, reason?: Error) => void) => Listener;
    onPrivmsg: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onAction: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onNotice: (handler: (target: string, user: string, message: string, msg: Notice) => void) => Listener;
    onNickChange: (handler: (oldNick: string | undefined, newNick: string, msg: MessageTypes.Commands.NickChange) => void) => Listener;
    onCtcp: (handler: (target: string, user: string, command: string, params: string, msg: PrivateMessage) => void) => Listener;
    onCtcpReply: (handler: (target: string, user: string, command: string, params: string, msg: Notice) => void) => Listener;
    onAnyMessage: (handler: (msg: Message<any, never>) => void) => Listener;
    protected _serverProperties: ServerProperties;
    protected _supportedFeatures: {
        [feature: string]: true | string;
    };
    protected _collectors: MessageCollector[];
    protected _clientCapabilities: Map<string, Capability>;
    protected _serverCapabilities: Map<string, ServerCapability>;
    protected _negotiatedCapabilities: Map<string, ServerCapability>;
    protected _pingOnInactivity: number;
    protected _pingTimeout: number;
    protected _pingCheckTimer?: NodeJS.Timer;
    protected _pingTimeoutTimer?: NodeJS.Timer;
    protected _currentNick: string;
    private _retryDelayGenerator?;
    private _retryTimer?;
    private readonly _logger;
    constructor(options: IRCClientOptions);
    setupConnection(): Promise<void>;
    readonly serverProperties: ServerProperties;
    pingCheck(): void;
    reconnect(message?: string): Promise<void>;
    registerMessageType(cls: MessageConstructor): void;
    knowsCommand(command: string): boolean;
    getCommandClass(command: string): MessageConstructor | undefined;
    connect(): Promise<void>;
    waitForRegistration(): Promise<void>;
    registerCapability(cap: Capability): Promise<Error | ServerCapability[]>;
    send(message: Message): void;
    sendRaw(line: string): void;
    onMessage<C extends MessageConstructor>(type: C, handler: EventHandler<ConstructedType<C>>, handlerName?: string): string;
    onMessage<T extends Message>(type: string, handler: EventHandler, handlerName?: string): string;
    removeMessageListener(handlerName: string): void;
    createMessage<T extends Message<T, X>, X extends Exclude<keyof T, keyof Message>>(type: MessageConstructor<T, X>, params: Partial<MessageParamValues<T>>, tags?: Map<string, string>): T;
    sendMessage<T extends Message<T, X>, X extends Exclude<keyof T, keyof Message>>(type: MessageConstructor<T, X>, params: Partial<MessageParamValues<T>>): void;
    sendMessageAndCaptureReply<T extends Message<T, X>, X extends Exclude<keyof T, keyof Message>>(type: MessageConstructor<T, X>, params: Partial<MessageParamValues<T>>): Promise<Message[]>;
    readonly isConnected: boolean;
    readonly isConnecting: boolean;
    readonly isRegistered: boolean;
    readonly currentNick: string;
    /** @private */
    collect(originalMessage: Message, ...types: MessageConstructor[]): MessageCollector;
    /** @private */
    stopCollect(collector: MessageCollector): void;
    join(channel: string, key?: string): void;
    part(channel: string): void;
    quit(message?: string): void;
    say(target: string, message: string): void;
    sendCTCP(target: string, type: string, message: string): void;
    action(target: string, message: string): void;
    protected getPassword(currentPassword?: string): Promise<string | undefined>;
    protected registerCoreMessageTypes(): void;
    protected _negotiateCapabilityBatch(capabilities: ServerCapability[][]): Promise<Array<ServerCapability[] | Error>>;
    protected _negotiateCapabilities(capList: ServerCapability[]): Promise<ServerCapability[] | Error>;
    protected _updateCredentials(newCredentials: Partial<IRCCredentials>): void;
    private handleEvents;
    private _startPingCheckTimer;
    private static _getReconnectWaitTime;
}
